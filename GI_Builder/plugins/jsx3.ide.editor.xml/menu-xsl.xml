<!--
  ~ Copyright (c) 2001-2014, TIBCO Software Inc.
  ~ Use, modification, and distribution subject to terms of license.
  -->
<data jsxid="jsxroot" jsxassignids="1">
  <record jsxtext="CDATA"
      jsxtip="Everything inside a CDATA section is ignored by the parser.&#10;&#10;![CDATA[cdata_content]]">
    <syntax>&lt;![CDATA[cdata_content]]&gt;</syntax>
  </record>
  <record jsxtext="apply-imports"
      jsxtip="xsl:apply-imports processes the current node using only template rules that were imported into the stylesheet element containing the current template rule; the node is processed in the current template rule's mode. It is an error if xsl:apply-imports is instantiated when the current template rule is null.&#10;&#10;&lt;xsl:import href=&quot;doc.xsl&quot;/&gt;&#10;  &lt;xsl:template match=&quot;example&quot;&gt;&#10;    &lt;div style=&quot;border: solid red&quot;&gt;&#10;      &lt;xsl:apply-imports/&gt;&#10;    &lt;/div&gt;&#10;  &lt;/xsl:template&gt;">
    <syntax>&lt;xsl:apply-imports/&gt;</syntax>
  </record>
  <record jsxtext="apply-templates"
      jsxtip="In the absence of a select attribute, the xsl:apply-templates instruction processes all of the children of the current node, including text nodes.&#10;&#10;&lt;xsl:template match=&quot;chapter&quot;&gt;&#10;  &lt;fo:block&gt;&#10;    &lt;xsl:apply-templates/&gt;&#10;  &lt;/fo:block&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:apply-templates select = node-set-expression mode = qualified_name&gt;&lt;!-- Content: (xsl:sort | xsl:with-param)* --&gt;&lt;/xsl:apply-templates&gt;</syntax>
  </record>
  <record jsxtext="attribute"
      jsxtip="The xsl:attribute element can be used to add attributes to result elements whether created by literal result elements in the stylesheet or by instructions such as xsl:element.&#10;&#10;&lt;xsl:attribute name=&quot;xmlns:xsl&quot; namespace=&quot;whatever&quot;&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;">
    <syntax>&lt;xsl:attribute name="ATTRIBUTE_NAME"&gt;&lt;/xsl:attribute&gt;</syntax>
  </record>
  <record jsxtext="attribute-set"
      jsxtip="The xsl:attribute-set element defines a named set of attributes. The name attribute specifies the name of the attribute set.  Attribute sets are used by specifying a use-attribute-sets attribute on xsl:element, xsl:copy or xsl:attribute-set elements. The value of the use-attribute-sets attribute is a whitespace-separated list of names of attribute sets.&#10;&#10;&lt;xsl:attribute-set name=&quot;title-style&quot;&gt;&#10;  &lt;xsl:attribute name=&quot;font-size&quot;&gt;12pt&lt;/xsl:attribute&gt;&#10;  &lt;xsl:attribute name=&quot;font-weight&quot;&gt;bold&lt;/xsl:attribute&gt;&#10;&lt;/xsl:attribute-set&gt;&#10;">
    <syntax>&lt;xsl:attribute-set name=qualified_name use-attribute-sets=qnames&gt;
  &lt;!-- Content: xsl:attribute* --&gt;
&lt;/xsl:attribute-set&gt;</syntax>
  </record>
  <record jsxtext="call-template"
      jsxtip="An xsl:call-template element invokes a template by name; it has a required name attribute that identifies the template to be invoked. Unlike xsl:apply-templates, xsl:call-template does not change the current node or the current node list.&#10;&#10;&lt;xsl:call-template name=qualified_name&gt;&#10;  &lt;!-- Content: xsl:with-param* --&gt;&#10;&lt;/xsl:call-template&gt; ">
    <syntax>&lt;xsl:call-template name=qualified_name&gt;
  &lt;!-- Content: xsl:with-param* --&gt;
&lt;/xsl:call-template&gt;</syntax>
  </record>
  <record jsxtext="choose"
      jsxtip="The xsl:choose element selects one among a number of possible alternatives. It consists of a sequence of xsl:when elements followed by an optional xsl:otherwise element. Each xsl:when element has a single attribute, test, which specifies an expression.&#10;&#10;&lt;xsl:choose&gt;&#10;  &lt;xsl:when expr=&quot;SCRIPT_EXPRESSION&quot; test=&quot;PATTERN_TO_MATCH&quot;&gt;&lt;/xsl:when&gt;&#10;  &lt;xsl:otherwise&gt;&lt;/xsl:otherwise&gt;&#10;&lt;/xsl:choose&gt; ">
    <syntax>&lt;xsl:choose&gt;
  &lt;!-- Content: (xsl:when+, xsl:otherwise?) --&gt;
&lt;/xsl:choose&gt;</syntax>
  </record>
  <record jsxtext="comment"
      jsxtip="The xsl:comment element is instantiated to create a comment node in the result tree.&#10;&#10; &lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt; ">
    <syntax>&lt;xsl:comment&gt;comment text&lt;/xsl:comment&gt;</syntax>
  </record>
  <record jsxtext="copy"
      jsxtip="The xsl:copy element provides an easy way of copying the current node. Instantiating the xsl:copy element creates a copy of the current node. The namespace nodes of the current node are automatically copied as well, but the attributes and children of the node are not automatically copied. The content of the xsl:copy element is a template for the attributes and children of the created node; the content is instantiated only for nodes of types that can have attributes or children (i.e. root nodes and element nodes).&#10;&#10;&lt;xsl:template match=&quot;@*|node()&quot;&gt;&#10;  &lt;xsl:copy&gt;&#10;    &lt;xsl:apply-templates select=&quot;@*|node()&quot;/&gt;&#10;  &lt;/xsl:copy&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:copy use-attribute-sets=qualified_names&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:copy&gt;</syntax>
  </record>
  <record jsxtext="copy-of"
      jsxtip="The xsl:copy-of element can be used to insert a result tree fragment into the result tree, without first converting it to a string as xsl:value-of does.  The required select attribute contains an expression. When the result of evaluating the expression is a result tree fragment, the complete fragment is copied into the result tree. When the result is a node-set, all the nodes in the set are copied in document order into the result tree; copying an element node copies the attribute nodes, namespace nodes and children of the element node as well as the element node itself; a root node is copied by copying its children. When the result is neither a node-set nor a result tree fragment, the result is converted to a string and then inserted into the result tree, as with xsl:value-of.&#10;&#10;&lt;xsl:template match=&quot;MELTING_POINT&quot;&gt;&#10;  &lt;xsl:copy-of select=&quot;..&quot;/&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:copy-of select=expression /&gt;</syntax>
  </record>
  <record jsxtext="decimal-format"
      jsxtip="The xsl:decimal-format element defines the symbols and characters used by the format-number function to convert numbers to strings. This element can be used more than once, but with certain limitations. Each element can have an optional name value assigned to it by using by the name attribute. However, you cannot repeat name values. Further, you can only omit the name attribute once. This element does not effect the behavior of the xsl:number and the xsl:value-of elements when they are used to format a number for display in the output. Nor does it effect the string function which has a default procedure for converting numbers to strings. The xsl:decimal-format element can only be a child of the xsl:stylesheet or the xsl:transform elements.&#10;&#10;&lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot; version=&quot;1.0&quot;&gt;&#10;  &lt;xsl:decimal-format name=&quot;myFormat&quot; digit=&quot;D&quot; /&gt;&#10;  &lt;xsl:template match=&quot;/&quot;&gt;&#10;    &lt;xsl:value-of select='format-number(123456789, &quot;D.0&quot;, &quot;myFormat&quot;)' /&gt;&#10;    &lt;xsl:value-of select='format-number(123456789, &quot;$DDD,DDD,DDD.DD&quot;, &quot;myFormat&quot;)' /&gt;&#10;  &lt;/xsl:template&gt;&#10;&lt;/xsl:stylesheet&gt;">
    <syntax>&lt;xsl:decimal-format name=qualified_name decimal-separator=char grouping-separator=char infinity=string minus-sign=char NaN=string percent=char per-mille=char zero-digit=char digit=char pattern-separator=char /&gt;</syntax>
  </record>
  <record jsxtext="element"
      jsxtip="The xsl:element element is used to create and name an element (node) that can appear in the output.&#10;&#10;&lt;xsl:for-each select=&quot;team/member&quot;&gt;&#10;  &lt;xsl:element name=&quot;team_member&quot;&gt;&#10;    &lt;xsl:value-of select=&quot;name&quot; /&gt;&#10;  &lt;/xsl:element&gt;&#10;&lt;/xsl:for-each&gt;">
    <syntax>&lt;xsl:element name = { qname } namespace = { uri-reference } use-attribute-sets = qualified_names&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:element&gt;</syntax>
  </record>
  <record jsxtext="fallback"
      jsxtip="The xsl:fallback element is designed to provide fallback code that can be run as an alternative when an XSLT processor fails to support an element.  This is not a self-closing element. The separate closing element is mandatory.&#10;&#10;&lt;xsl:template match=&quot;/&quot;&gt;&#10;  &lt;xsl:list-name&gt;&#10;    &lt;xsl:fallback&gt;&#10;      &lt;xsl:for-each select=&quot;team/member&quot;&gt;&#10;        Team Member: &lt;xsl:value-of select=&quot;name&quot; /&gt;&#10;      &lt;/xsl:for-each&gt;&#10;    &lt;/xsl:fallback&gt;&#10;  &lt;/xsl:list-name&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:fallback&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:fallback&gt;</syntax>
  </record>
  <record jsxtext="for-each"
      jsxtip="The xsl:for-each element loops through each node in a node set in its order of occurrence and applies the same template to each node. A node set is simply the collection of all of the same XML tags (nodes) in an XML file. This process is also referred to as iterating over a set of nodes. The template is contained inside the xsl:for-each element between the opening and closing element.&#10;&#10;&lt;xsl:for-each select=&quot;customers/customer&quot;&gt;&#10;  &lt;tr&gt;&#10;    &lt;th&gt;&lt;xsl:apply-templates select=&quot;name&quot;/&gt;&lt;/th&gt;&#10;    &lt;xsl:for-each select=&quot;order&quot;&gt;&#10;      &lt;td&gt;&lt;xsl:apply-templates/&gt;&lt;/td&gt;&#10;    &lt;/xsl:for-each&gt;&#10;  &lt;/tr&gt;&#10;&lt;/xsl:for-each&gt;">
    <syntax>&lt;xsl:for-each select=node-set-expression&gt;
  &lt;!-- Content: (xsl:sort*, template) --&gt;
&lt;/xsl:for-each&gt;</syntax>
  </record>
  <record jsxtext="if"
      jsxtip="The xsl:if element evaluates an expression which returns a Boolean result to determine if a template should be instantiated. The evaluation is a simple True or False test on a defined condition or a set of conditions. If the test returns True, the template is applied and the results are displayed in the output. If False, the template is not applied (i.e., the contents between the opening and closing xsl:if are skipped over).&#10;&#10;&lt;xsl:template match=&quot;item&quot;&gt;&#10;  &lt;tr&gt;&#10;    &lt;xsl:if test=&quot;position() mod 2 = 0&quot;&gt;&#10;      &lt;xsl:attribute name=&quot;bgcolor&quot;&gt;yellow&lt;/xsl:attribute&gt;&#10;    &lt;/xsl:if&gt;&#10;    &lt;xsl:apply-templates/&gt;&#10;  &lt;/tr&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:if test = boolean-expression&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:if&gt;</syntax>
  </record>
  <record jsxtext="import"
      jsxtip="The xsl:import element is a top-level element that is used to import the contents of one style sheet into another.&#10;&#10;&lt;xsl:import href=&quot;example1.xsl&quot;/&gt;&#10;  &lt;xsl:template match=&quot;/&quot;&gt;&#10;&lt;xsl:apply-imports/&gt;">
    <syntax>&lt;xsl:import href = uri-reference /&gt;</syntax>
  </record>
  <record jsxtext="include"
      jsxtip="Includes the contents of one style sheet into another. Note: An included style sheet has the same precedence as the including style sheet&#10;&#10;&lt;xsl:include href=&quot;URI&quot;/&gt;">
    <syntax>&lt;xsl:include href="URI"/&gt;</syntax>
  </record>
  <record jsxtext="key"
      jsxtip="Declares a named key that can be used in the style sheet with the key() function&#10;&#10; &lt;xsl:key name=&quot;pid&quot; match=&quot;person&quot; use=&quot;@id&quot;/&gt;">
    <syntax>&lt;xsl:key name="name" match="pattern" use="expression"/&gt;</syntax>
  </record>
  <record jsxtext="message"
      jsxtip="Writes a message to the output (used to report errors)&#10;&#10;&lt;xsl:if test=&quot;supervisor=''&quot;&gt;&#10;  &lt;xsl:message terminate=&quot;yes&quot;&gt;Error: Supervisor is an empty string!&lt;/xsl:message&gt;&#10;&lt;/xsl:if&gt;">
    <syntax>&lt;xsl:message terminate = "yes" | "no"&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:message&gt;</syntax>
  </record>
  <record jsxtext="namespace-alias"
      jsxtip="Replaces a namespace in the style sheet to a different namespace in the output&#10;&#10;&lt;xsl:namespace-alias stylesheet-prefix=&quot;wxsl&quot; result-prefix=&quot;xsl&quot;/&gt;">
    <syntax>&lt;xsl:namespace-alias stylesheet-prefix=prefix | "#default" result-prefix=prefix | "#default" /&gt;</syntax>
  </record>
  <record jsxtext="number"
      jsxtip="Determines the integer position of the current node and formats a number&#10;&#10;&lt;xsl:number value=&quot;50000&quot; grouping-separator=&quot;,&quot;/&gt;">
    <syntax>&lt;xsl:number count="expression" level="single|multiple|any" from="expression" value="expression" format="formatstring" lang="languagecode" letter-value="alphabetic|traditional" grouping-separator="character" grouping-size="number"/&gt;</syntax>
  </record>
  <record jsxtext="otherwise"
      jsxtip="Specifies a default action for the xsl:choose element&#10;&#10;&lt;xsl:choose&gt;&#10;  &lt;xsl:when test=&quot;cost&amp;gt;'10'&quot;&gt;**&lt;xsl:value-of select=&quot;cost&quot;/&gt;&lt;/xsl:when&gt;&#10;  &lt;xsl:otherwise&gt;&lt;xsl:value-of select=&quot;cost&quot;/&gt;&lt;/xsl:otherwise&gt;&#10;&lt;/xsl:choose&gt;">
    <syntax>&lt;xsl:otherwise&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:otherwise&gt;</syntax>
  </record>
  <record jsxtext="output"
      jsxtip="Defines the format of the output document&#10;&#10;&lt;xsl:output method=&quot;xml&quot; version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot; indent=&quot;yes&quot;/&gt;">
    <syntax>&lt;xsl:output method="xml|html|text|name" version="string" encoding="string" omit-xml-declaration="yes|no" standalone="yes|no" doctype-public="string" doctype-system="string" cdata-section-elements="namelist" indent="yes|no" media-type="string"/&gt;</syntax>
  </record>
  <record jsxtext="param"
      jsxtip="Declares a local or global parameter&#10;&#10;&lt;xsl:template name=&quot;show_description&quot; match=&quot;/&quot;&gt;&#10;  &lt;xsl:param name=&quot;description&quot;/&gt;&#10;    &lt;xsl:for-each select=&quot;section/item&quot;&gt;&#10;      Description: &lt;xsl:value-of select=&quot;$description&quot;/&gt;&#10;    &lt;/xsl:for-each&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:param name="name" select=expression&gt;&lt;!-- Content: template --&gt;&lt;/xsl:param&gt;</syntax>
  </record>
  <record jsxtext="preserve-space"
      jsxtip="Defines the elements for which white space should be preserved&#10;&#10;&lt;xsl:preserve-space elements=&quot;full_name address&quot; /&gt;">
    <syntax>&lt;xsl:preserve-space elements = tokens /&gt;</syntax>
  </record>
  <record jsxtext="processing-instruction"
      jsxtip="Writes a processing instruction to the output&#10;&#10;&lt;xsl:processing-instruction name=&quot;xml-stylesheet&quot;&gt;href=&quot;styles.css&quot; type=&quot;text/css&quot;&lt;/xsl:processing-instruction&gt;">
    <syntax>&lt;xsl:processing-instruction name={ ncname }&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:processing-instruction&gt;</syntax>
  </record>
  <record jsxtext="sort"
      jsxtip="Sorts the output&#10;&#10;&lt;xsl:sort select=&quot;last_name&quot;/&gt;">
    <syntax>&lt;xsl:sort select="expression" lang="language-code" data-type="text|number|qname" order="ascending|descending" case-order="upper-first|lower-first"/&gt;</syntax>
  </record>
  <record jsxtext="strip-space"
      jsxtip="Defines the elements for which white space should be removed&#10;&#10;&lt;xsl:strip-space elements=&quot;first_name last_name&quot; /&gt;">
    <syntax>&lt;xsl:strip-space elements=tokens /&gt;</syntax>
  </record>
  <record jsxtext="stylesheet"
      jsxtip="Defines the root element of a style sheet&#10;&#10;&lt;xsl:stylesheet version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;">
    <syntax>&lt;?xml version="1.0" ?&gt;
  &lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;!-- Content: (xsl:import*, top-level-elements) --&gt;
&lt;/xsl:stylesheet&gt;</syntax>
  </record>
  <record jsxtext="template"
      jsxtip="A template rule is specified with the xsl:template element. The match attribute is a Pattern that identifies the source node or nodes to which the rule applies. The match attribute is required unless the xsl:template element has a name attribute (see [6 Named Templates]). It is an error for the value of the match attribute to contain a VariableReference. The content of the xsl:template element is the template that is instantiated when the template rule is applied.&#10;&#10;&lt;xsl:template match=&quot;/&quot;&gt;&#10;  &lt;h2&gt;Phone List&lt;/h2&gt;&#10;  &lt;xsl:apply-templates/&gt;&#10;&lt;/xsl:template&gt;&#10;&lt;xsl:template match=&quot;Person&quot;&gt;&#10;  &lt;p&gt;&#10;    &lt;xsl:apply-templates select=&quot;full_name&quot;/&gt;&#10;    &lt;xsl:apply-templates select=&quot;number&quot;/&gt;&#10;  &lt;/p&gt;&#10;&lt;/xsl:template&gt;">
    <syntax>&lt;xsl:template match=pattern name=qualified_name priority=number mode=qname&gt;
  &lt;!-- Content: (xsl:param*, template) --&gt;
&lt;/xsl:template&gt;</syntax>
  </record>
  <record jsxtext="text"
      jsxtip="Writes literal text to the output&#10;&#10;&lt;xsl:if test=&quot;position() &lt; last()-1&quot;&gt;&#10;  &lt;xsl:text&gt;, &lt;/xsl:text&gt;&#10;&lt;/xsl:if&gt;">
    <syntax>&lt;xsl:text disable-output-escaping="yes"|"no"&gt;&lt;!-- Content: #PCDATA --&gt;&lt;/xsl:text&gt;</syntax>
  </record>
  <record jsxtext="transform"
      jsxtip="Defines the root element of a style sheet. The xsl:stylesheet and xsl:transform elements are completely synonymous elements. Both are used to define the root element of the style sheet.&#10;&#10;&lt;xsl:transform version=&quot;1.0&quot; xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&gt;">
    <syntax>&lt;xsl:transform id=id extension-element-prefixes=tokens exclude-result-prefixes=tokens version=number&gt;
  &lt;!-- Content: (xsl:import*, top-level-elements) --&gt;
&lt;/xsl:transform&gt;</syntax>
  </record>
  <record jsxtext="value-of"
      jsxtip="Extracts the value of a selected node&#10;&#10;&lt;xsl:value-of select=&quot;person/first_name&quot;/&gt;">
    <syntax>&lt;xsl:value-of select="expression" disable-output-escaping="yes|no"/&gt;</syntax>
  </record>
  <record jsxtext="variable"
      jsxtip="Declares a local or global variable&#10;&#10;&lt;xsl:variable name=&quot;color&quot; select=&quot;'red'&quot;/&gt;&#10;&lt;xsl:copy-of select=&quot;$color&quot;/&gt;">
    <syntax>&lt;xsl:variable name=qname select=expression&gt;&lt;!-- Content: template --&gt;&lt;/xsl:variable&gt;</syntax>
  </record>
  <record jsxtext="when"
      jsxtip="Specifies an action for the 'choose' element.  The xsl:when element is used to specify an action for the xsl:choose element. The xsl:when element evaluates an expression, and if it returns true, an action is performed.&#10;&#10;&lt;xsl:choose&gt;&#10;  &lt;xsl:when test=&quot;cost&amp;gt;'10'&quot;&gt;**&lt;xsl:value-of select=&quot;cost&quot;/&gt;&lt;/xsl:when&gt;&#10;  &lt;xsl:otherwise&gt;&lt;xsl:value-of select=&quot;cost&quot;/&gt;&lt;/xsl:otherwise&gt;&#10;&lt;/xsl:choose&gt;">
    <syntax>&lt;xsl:when test=boolean-expression&gt;
  &lt;!-- Content: template --&gt;
&lt;/xsl:when&gt;</syntax>
  </record>
  <record jsxtext="with-param"
      jsxtip="Defines the value of a parameter to be passed into a template&#10;&#10;&lt;xsl:call-template name=&quot;show_element&quot;&gt;&#10;  &lt;xsl:with-param name=&quot;last_name&quot;/&gt;&#10;&lt;/xsl:call-template&gt;">
    <syntax>&lt;xsl:with-param name=qname select=expression&gt;&lt;!-- Content: template --&gt;&lt;/xsl:with-param&gt;</syntax>
  </record>
</data>
